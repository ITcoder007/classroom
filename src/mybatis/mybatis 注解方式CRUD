·新增加接口CategoryMapper ，并在接口中声明的方法上，加上注解
	对比配置文件Category.xml，其实就是把SQL语句从XML挪到了注解上来
	
·不同场合下，三层架构的概念也是不一样的。  
	你说到的三层架构大概是Service层，DAO层 ， Controller这三层。 没错DAO层就是Mapper
	
·那么Category是如何和Mapper建立对应关系呢？
在这个例子里，Mapper使用的是注解的方式，比如
    @Select(" select * from category_ ")  
    public List<Category> list();
这个方法会返回泛型是Category的集合，Mybatis就知道把数据查出来之后，放进Category对象了。

·一对多
	a.增加CategoryMapper接口，查询所有Category
	//获取Category类本身
		@Select(" select * from category_ ")
	//@Results 通过@Result和@Many中调用ProductMapper.listByCategory()方法相结合，来获取一对多关系
	    @Results({ 
	                @Result(property = "id", column = "id"),
	                @Result(property = "products", javaType = List.class, column = "id", many = @Many(select = "com.how2java.mapper.ProductMapper.listByCategory") )
	            })
	    public List<Category> list();
	b.新增接口ProductMapper
	//注解@Select用于根据分类id获取产品集合
		@Select(" select * from product_ where cid = #{cid}")
	    public List<Product> listByCategory(int cid);
·mybatis-config.xml	
	<mappers>
        <mapper resource="com/how2java/pojo/Category.xml"/>
        <mapper class="com.how2java.mapper.CategoryMapper"/> 
        <mapper class="com.how2java.mapper.ProductMapper"/> 
    </mappers>
	

在默认情况下，会把类的属性和表的字段，按照一对一的关系进行匹配。
	至于注解如何工作，请参考注解高级教程：
	http://how2j.cn/k/annotation/annotation-like-hibernate/1058.html

·多对一
除了配置xml、实体类、还要写CRUD的xml
public interface ProductMapper {
    @Select(" select * from product_ ")
    @Results({ 
        @Result(property="category",column="cid",one=@One(select="com.how2java.mapper.CategoryMapper.get")) 
    })
    public List<Product> list();

疑问：为何一对多有注解：@Result(property = "id", column = "id"),而多对一没有。


·多对多 （一个订单有多个订单项 ———— 一个产品对应多个订单项）
	·order对应多个item，每个item对应一个product，反过来product对应多个item，一个item对应一个order
	·OrderItem类与Order类互相引用，不会出现死循环吗？
	不会。两个对象中都相互持有对方的引用，也就是都有一个指针指向对方，相当于双向链表，而不是说我的内存里边有你的对象的内存，你的对象内存又含有我的对象内存，这样一直循环下去。
·一条订单项记录只有id,oid,pid,number
本来订单与产品是多对多的关系，然后引入订单项，变成订单与订单项一对多，产品与订单项一对多，从而间接形成订单与产品的多对多关系


·动态SQL语句
	SQL语句使用SQL类的方式构建
	改造mapper

	